Effective Go Error Handling
Tricks and shortcuts you don't need a library for
25 Sep 2014

Kevin Gillette
@kevingillette
https://github.com/xtgo
https://github.com/xtblog/gotalks

* Errors

- ... are handled visibly and explicitly, using normal control flow and value-passing.
- ... are *not* exceptions.
- The panic/recover mechanism is similar to exception handling, but is not used for that purpose.

* panic/recover (1/2)

- Mostly generated by the runtime when slice out-of-bounds indexing, divide-by-zero, etc. occurs.
- Libraries should not expose panic as a normal part of their exported APIs.
- Applications should not be expected to recover panics from libraries.

* panic/recover (2/2)

- Libraries may panic when the programmer violates API expectations not enforced by the type system; such panics should be documented.
- Libraries that feature inversion of control (e.g. net/http Server) may recover panics originating from application code.
- Libraries and applications may use panic internally if recovered prior to crossing package boundaries, though this is often discouraged.

* Miscellany

- Libraries must not make program life-cycle decisions, such as via `os.Exit` or `log.Fatal*`.
- In other words, as a library author, it's not your right or privilege to decide what is or is not a fatal condition; your library must not place itself in an unusable state through mis-design.
- Libraries should *not* produce an unrecovered panic in a goroutine they create; there will be no way for the process to survive.

* Error-Handling Verbosity (1/3)

    func WriteEmphatically(w io.Writer, p []byte) error {
        _, err := io.WriteString(w, "Hey you: ")
        if err != nil {
            return err
        }
        _, err = w.Write(p)
        if err != nil {
            return err
        }
        _, err = io.WriteString(w, "!!!\n")
        return err
    }

- Checking every _distinct_ error is important, but these errors are related.
- Readers and Writers follow a byte-stream model: reliable with guaranteed order.
- With most implementations, there are no temporary errors.

* Error-Handling Verbosity (2/3)

    func NewSafeWriter(w io.Writer) *SafeWriter {
        return &SafeWriter{w: w}
    }

    type SafeWriter struct {
        w   io.Writer
        err error
    }

    func (sw *SafeWriter) Err() error { return sw.err }

    func (sw *SafeWriter) Write(p []byte) (n int, err error) {
        if sw.err != nil {
            return 0, err
        }
        n, sw.err = sw.w.Write(p)
        return n, sw.err
    }

* Error-Handling Verbosity (3/3)

    func WriteEmphatically(w io.Writer, p []byte) error {
        sw := &SafeWriter{
        io.WriteString(w, "Hey you: ")
        w.Write(p)
        _, err = io.WriteString(w, "!!!\n")
        return err
    }

- bufio.Writer caches errors and behaves similarly; technique of checking error only on Flush used by various stdlib packages.
- Notable exceptions: timeouts/deadlines, "non-reliable" protocols (UDP).
- Buggy or special-cased in-memory implementations may violate this convention.

* Error-Handling Shortcuts (1/2)

Call each function in sequence, returning the first non-nil error, or nil if all succeeded.

  func ShortCircuit(funcs ...func() error) error {
      for _, f := range funcs {
          if err := f(); err != nil {
              return err
          }
      }
      return nil
  }

* Error-Handling Shortcuts (2/2)

To sync, chmod, and close an open file, `f`, just do:

  err := ShortCircuit(
      func() error { return f.Chmod(0400) },
      f.Sync,
      f.Close,
      func() error { return os.Rename(f.Name(), newName) },
  )

or

  steps := []func() error{
      func() error { return f.Chmod(0400) },
      f.Sync,
      f.Close,
      func() error { return os.Rename(f.Name(), newName) },
  }
  err := ShortCircuit(steps...)

* Error Handling in HTTP Handlers (1/4)

  func init() {
      http.HandleFunc("/", Handler)
  }

  func Handler(w http.ResponseWriter, r *http.Request) {
      if !condition1 {
          http.Error(w, "condition 1 failed", http.StatusBadRequest)
          return
      }
      // ... do more stuff ...
      if err != nil {
          http.Error(w, err.Error(), http.StatusInternalServerError)
          return
      }
  }

* Error Handling in HTTP Handlers (2/4)

  type StatusError interface {
      Status() int
      error
  }

  func NewStatusError(status int, message string) StatusError {
      return httpError{status, message}
  }

  type httpError struct {
      status  int
      message string
  }

  func (e httpError) Status() int    { return e.status }
  func (e httpError) Error()  string { return e.message }

* Error Handling in HTTP Handlers (3/4)

  type ErrorHandler func(w http.ResponseWriter, r *http.Request) error

  func (h ErrorHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
      err := h(w, r)
      if err == nil {
          return
      }
      status := http.StatusInternalServerError
      if serr, ok := err.(StatusError); ok {
          status = serr.Status()
      }
      http.Error(w, err.Error(), status)
  }

* Error Handling in HTTP Handlers (4/4)

  func init() {
      http.Handle("/", ErrorHandler(Handler))
  }

  func Handler(w http.ResponseWriter, r *http.Request) error {
      if !condition1 {
          return NewStatusError(http.StatusBadRequest, "condition 1 failed")
      }
      // ... do more stuff ...
      if err != nil {
          return err
      }
  }
